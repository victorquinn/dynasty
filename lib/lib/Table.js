// Generated by CoffeeScript 1.6.3
(function() {
  var Q, Table, awsTrans, dataTrans, debug, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  awsTrans = require('./aws-translators');

  dataTrans = require('./data-translators');

  _ = require('lodash');

  Q = require('q');

  debug = require('debug')('dynasty');

  Table = (function() {
    function Table(parent, name) {
      var _this = this;
      this.parent = parent;
      this.name = name;
      this.find = __bind(this.find, this);
      this.update = this.insert;
      this.key = this.describe().then(function(tableDescription) {
        _this.description = tableDescription.Table;
        return awsTrans.getKeySchema(tableDescription);
      }).then(function(keySchema) {
        _this.hasRangeKey = 4 === _.size(_.compact(_.values(keySchema)));
        return keySchema;
      });
    }

    /*
    Item Operations
    */


    Table.prototype.find = function(continuer) {
      var awsParams, deferred, hashKeySpecified, keyParam, minRangeSpecified, options, promise, rangeKeySpecified, specifiedMinRange,
        _this = this;
      deferred = Q.defer();
      promise = deferred.promise;
      keyParam = {};
      awsParams = {
        TableName: this.name,
        Key: keyParam
      };
      hashKeySpecified = rangeKeySpecified = minRangeSpecified = false;
      specifiedMinRange = null;
      options = {};
      promise.options = function(opts) {
        _.extend(options, opts);
        return promise;
      };
      promise.hash = function(hashKeyValue) {
        _this.key.then(function(keySchema) {
          keyParam.HashKeyElement = {};
          keyParam.HashKeyElement[keySchema.hashKeyType] = hashKeyValue + '';
          return hashKeySpecified = true;
        });
        promise.range = function(rangeKeyValue) {
          _this.key.then(function(keySchema) {
            if (!_this.hasRangeKey) {
              return deferred.reject(new Error("Specifying range key for table without range key"));
            } else {
              keyParam.RangeKeyElement = {};
              keyParam.RangeKeyElement[keySchema.rangeKeyType] = rangeKeyValue + '';
              return rangeKeySpecified = true;
            }
          });
          return promise;
        };
        promise.minRange = function(minRange) {
          _this.key.then(function(keySchema) {
            if (!_this.hasRangeKey) {
              return deferred.reject(new Error("Specifying minimum range key for table without range key"));
            } else {
              minRangeSpecified = true;
              return specifiedMinRange = minRange;
            }
          });
          return promise;
        };
        return promise;
      };
      process.nextTick(function() {
        return _this.key.then(function(keySchema) {
          if (!promise.isRejected()) {
            debug("find() - " + (JSON.stringify(awsParams)));
            if ((rangeKeySpecified && _this.hasRangeKey) || (hashKeySpecified && !_this.hasRangeKey)) {
              awsParams = _.pick(_.extend(awsParams, options), 'HashKeyElement', 'AttributesToGet', 'TableName', 'Key', 'ConsistentRead', 'ReturnConsumedCapacity');
              return _this.parent.execute('GetItem', awsParams).then(function(data) {
                data = dataTrans.fromDynamo(data.Item);
                deferred.notify(data ? [data] : []);
                return data;
              }).then(deferred.resolve)["catch"](deferred.reject);
            } else if (!rangeKeySpecified && !hashKeySpecified) {
              delete awsParams.Key;
              awsParams = _.pick(_.extend(awsParams, options), 'TableName', 'AttributesToGet', 'ExclusiveStartKey', 'Limit', 'ScanFilter', 'Segment', 'Select', 'TotalSegments', 'ReturnConsumedCapacity');
              return awsTrans.processAllPages(deferred, _this.parent.execute, 'Scan', awsParams, continuer);
            } else if (!rangeKeySpecified && _this.hasRangeKey) {
              awsParams.HashKeyValue = awsParams.Key.HashKeyElement;
              delete awsParams.Key;
              if (minRangeSpecified) {
                if (awsParams.RangeKeyCondition == null) {
                  awsParams.RangeKeyCondition = {
                    AttributeValueList: [dataTrans.toDynamo(specifiedMinRange)],
                    ComparisonOperator: 'GT'
                  };
                }
              }
              awsParams = _.pick(_.extend(awsParams, options), 'TableName', 'HashKeyValue', 'RangeKeyCondition', 'HashKeyCondition', 'AttributesToGet', 'ConsistentRead', 'ExclusiveStartKey', 'IndexName', 'KeyConditions', 'Limit', 'ReturnConsumedCapacity', 'ScanIndexForward', 'Select');
              return awsTrans.processAllPages(deferred, _this.parent.execute, 'Query', awsParams, continuer);
            }
          }
        }).done();
      });
      return promise;
    };

    Table.prototype.insert = function(obj) {
      var allPutOps, awsParams, currentNdx, dataLength, deferred, item, itemSize, items, prop, putRequests, _i, _len;
      if (_.isArray(obj)) {
        deferred = Q.defer();
        allPutOps = [];
        itemSize = function(item) {
          var prop, sum, val;
          sum = 0;
          for (prop in item) {
            val = item[prop];
            sum += prop.length + (val + '').length;
          }
          return sum;
        };
        currentNdx = 0;
        while (currentNdx < obj.length) {
          items = [];
          dataLength = 0;
          while (items.length < 25 && dataLength < 1048576 && currentNdx < obj.length) {
            item = obj[currentNdx++];
            dataLength += itemSize(item);
            items.push(item);
          }
          awsParams = {};
          awsParams.RequestItems = {};
          putRequests = [];
          for (_i = 0, _len = items.length; _i < _len; _i++) {
            item = items[_i];
            for (prop in item) {
              item[prop] = dataTrans.toDynamo(item[prop]);
            }
            putRequests.push({
              PutRequest: {
                Item: item
              }
            });
          }
          awsParams.RequestItems[this.name] = putRequests;
          allPutOps.push(this.parent.execute('BatchWriteItem', awsParams)["catch"](function(error) {
            console.log(error);
            return deferred.reject(error);
          }).then(function(data) {
            deferred.notify(data);
            return W.resolve(data);
          }));
        }
        return Q.all(allPutOps).then(deferred.resolve)["catch"](deferred.reject);
      } else {
        awsParams = {
          TableName: this.name,
          Item: _.transform(obj, function(res, val, key) {
            return res[key] = dataTrans.toDynamo(val);
          })
        };
        return this.parent.execute('PutItem', awsParams);
      }
    };

    Table.prototype.remove = function(params, options, callback) {
      var awsParams, deferred, enableHash, enableRange, hashKeySpecified, keyParam, permitRemovingAll, permitRemovingOne, permitRemovingSome, promise, rangeKeySpecified, removeNarySpecifiers, specifiedHashKey, specifiedRangeKey,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      deferred = Q.defer();
      promise = deferred.promise;
      keyParam = {};
      awsParams = {
        TableName: this.name,
        Key: keyParam
      };
      hashKeySpecified = rangeKeySpecified = false;
      specifiedHashKey = specifiedRangeKey = null;
      options = {};
      promise.options = function(opts) {
        _.extend(options, opts);
        return promise;
      };
      enableHash = function() {
        return promise.hash = function(hashKeyValue) {
          _this.key.then(function(keySchema) {
            keyParam[keySchema.hashKeyName] = {};
            keyParam[keySchema.hashKeyName][keySchema.hashKeyType] = hashKeyValue + '';
            hashKeySpecified = true;
            return specifiedHashKey = hashKeyValue + '';
          });
          return promise;
        };
      };
      enableRange = function() {
        return promise.range = function(rangeKeyValue) {
          _this.key.then(function(keySchema) {
            if (!_this.hasRangeKey) {
              return deferred.reject(new Error("Specifying range key for table without range key"));
            } else {
              keyParam[keySchema.rangeKeyName] = {};
              keyParam[keySchema.rangeKeyName][keySchema.rangeKeyType] = rangeKeyValue + '';
              rangeKeySpecified = true;
              return specifiedRangeKey = rangeKeyValue + '';
            }
          });
          return promise;
        };
      };
      removeNarySpecifiers = function() {
        var specifier, _i, _len, _ref, _results;
        _ref = ['one', 'many', 'all'];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          specifier = _ref[_i];
          _results.push(delete promise[specifier]);
        }
        return _results;
      };
      permitRemovingOne = false;
      promise.one = function() {
        permitRemovingOne = true;
        removeNarySpecifiers();
        enableHash();
        enableRange();
        return promise;
      };
      permitRemovingSome = false;
      promise.many = function() {
        permitRemovingSome = true;
        removeNarySpecifiers();
        enableHash();
        return promise;
      };
      permitRemovingAll = false;
      promise.all = function() {
        permitRemovingAll = true;
        removeNarySpecifiers();
        return promise;
      };
      process.nextTick(function() {
        return _this.key.then(function(keySchema) {
          var allDeleteOps, deleteCount, deleter, op;
          if (!promise.isRejected()) {
            debug("remove() - " + (JSON.stringify(awsParams)));
            if (_this.hasRangeKey) {
              if (permitRemovingOne && (!hashKeySpecified || !rangeKeySpecified)) {
                return deferred.reject(new Error('Single element removal specified on hash/range table without specifying both a hash and range key'));
              }
              if (permitRemovingSome && !hashKeySpecified) {
                return deferred.reject(new Error('Partial multiple element removal specified on a hash/range table without specifying a hash key'));
              }
              if (permitRemovingAll && (hashKeySpecified || rangeKeySpecified)) {
                return deferred.reject(new Error('You cannot specify a hash or range key when attempting to remove all elements'));
              }
            } else {
              if (rangeKeySpecified) {
                return deferred.reject(new Error('Range key specified for table without range key'));
              }
              if (permitRemovingOne && !hashKeySpecified) {
                return deferred.reject(new Error('Single element removal specified on hash table without specifying hash key'));
              }
            }
            if (!permitRemovingOne && !permitRemovingSome && !permitRemovingAll) {
              return deferred.reject(new Error('Remove requires one(), many(), or all() to be called'));
            }
            deleteCount = 0;
            allDeleteOps = [];
            deleter = function(items) {
              var deleteRequests, item, requestKey, _i, _len;
              if (items.length === 0) {
                return;
              }
              deleteRequests = [];
              for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                requestKey = {};
                requestKey.HashKeyElement = {};
                requestKey.HashKeyElement[keySchema.hashKeyType] = item[keySchema.hashKeyName] + '';
                if (keySchema.rangeKeyName) {
                  requestKey.RangeKeyElement = {};
                  requestKey.RangeKeyElement[keySchema.rangeKeyType] = item[keySchema.rangeKeyName] + '';
                }
                deleteRequests.push({
                  DeleteRequest: {
                    Key: requestKey
                  }
                });
              }
              deleteCount += deleteRequests.length;
              deferred.notify({
                Count: deleteCount
              });
              awsParams = {};
              awsParams.RequestItems = {};
              awsParams.RequestItems[_this.name] = deleteRequests;
              return allDeleteOps.push(_this.parent.execute('BatchWriteItem', awsParams));
            };
            op = Q();
            if (hashKeySpecified && !_this.hasRangeKey) {
              op = _this.find().options({
                Limit: 25
              }).hash(specifiedHashKey).progress(deleter);
            } else if (rangeKeySpecified && _this.hasRangeKey) {
              op = _this.find().options({
                Limit: 25
              }).hash(specifiedHashKey).range(specifiedRangeKey).progress(deleter);
            } else if (permitRemovingAll && !rangeKeySpecified && !hashKeySpecified) {
              op = _this.find().options({
                Limit: 25
              }).progress(deleter);
            } else if (permitRemovingSome && !rangeKeySpecified && _this.hasRangeKey && hashKeySpecified) {
              op = _this.find().hash(specifiedHashKey).options({
                Limit: 25
              }).progress(deleter);
            }
            return op.then(function() {
              return Q.all(allDeleteOps);
            }).then(function() {
              return {
                Count: deleteCount
              };
            }).then(deferred.resolve)["catch"](deferred.reject);
          }
        });
      });
      return promise;
    };

    /*
    Table Operations
    */


    Table.prototype.describe = function(callback) {
      if (callback == null) {
        callback = null;
      }
      debug('describe() - ' + this.name);
      return this.parent.execute('DescribeTable', {
        TableName: this.name
      });
    };

    Table.prototype.drop = function(callback) {
      if (callback == null) {
        callback = null;
      }
      return this.parent.drop(this.name(callback));
    };

    return Table;

  })();

  module.exports = Table;

}).call(this);
