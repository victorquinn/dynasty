// Generated by CoffeeScript 1.6.3
(function() {
  var Q, aws, crypto, events, http, https;

  events = require('events');

  crypto = require('crypto');

  http = require('http');

  https = require('https');

  Q = require('q');

  aws = function(spec) {
    var auth, execute, my, that;
    that = new events.EventEmitter();
    that.setMaxListeners(0);
    my = {};
    my.accessKeyId = spec.accessKeyId;
    my.secretAccessKey = spec.secretAccessKey;
    my.endpoint = spec.endpoint || 'dynamodb.us-east-1.amazonaws.com';
    my.port = spec.port || 80;
    my.agent = spec.agent;
    my.retries = spec.retries || 3;
    if (spec.sessionToken && spec.sessionExpires) {
      my.access = {
        sessionToken: spec.sessionToken,
        secretAccessKey: spec.secretAccessKey,
        accessKeyId: spec.accessKeyId,
        expiration: spec.sessionExpires
      };
    }
    execute = function(op, data) {
      var cb, deferred;
      deferred = Q.defer();
      cb = function(err, data) {
        if (err) {
          return deferred.reject(err);
        } else {
          return deferred.resolve(data);
        }
      };
      auth(function(err) {
        var auth, dtStr, encoding, executeRequest, headers, hmac, options, retry, rqBody, sha, sts;
        if (err) {
          return cb(err);
        } else {
          dtStr = (new Date).toUTCString();
          rqBody = JSON.stringify(data);
          sts = "POST" + "\n" + "/" + "\n" + "" + "\n" + ("host" + ":" + my.endpoint + "\n" + "x-amz-date" + ":" + dtStr + "\n" + "x-amz-security-token" + ":" + my.access.sessionToken + "\n" + "x-amz-target" + ":" + "DynamoDB_20111205." + op + "\n") + "\n" + rqBody;
          sha = crypto.createHash("sha256");
          sha.update(new Buffer(sts, "utf8"));
          hmac = crypto.createHmac("sha256", my.access.secretAccessKey);
          hmac.update(sha.digest());
          auth = "AWS3" + " " + "AWSAccessKeyId" + "=" + my.access.accessKeyId + "," + "Algorithm" + "=" + "HmacSHA256" + "," + "SignedHeaders" + "=" + "host;x-amz-date;x-amz-target;x-amz-security-token" + "," + "Signature" + "=" + hmac.digest(encoding = "base64");
          headers = {
            Host: my.endpoint,
            "x-amz-date": dtStr,
            "x-amz-security-token": my.access.sessionToken,
            "X-amz-target": "DynamoDB_20111205." + op,
            "X-amzn-authorization": auth,
            date: dtStr,
            "content-type": "application/x-amz-json-1.0",
            "content-length": Buffer.byteLength(rqBody, "utf8")
          };
          options = {
            host: my.endpoint,
            port: my.port,
            path: "/",
            method: "POST",
            headers: headers,
            agent: my.agent
          };
          executeRequest = function(cb) {
            var req;
            req = http.request(options, function(res) {
              var body;
              body = "";
              res.on("data", function(chunk) {
                return body += chunk;
              });
              return res.on("end", function() {
                var json;
                if (!cb) {
                  return;
                }
                try {
                  json = JSON.parse(body);
                } catch (_error) {
                  err = _error;
                  cb(err);
                  return;
                }
                if (res.statusCode >= 300) {
                  err = new Error(op + " [" + res.statusCode + "]: " + (json.message || json["__type"]));
                  err.type = json["__type"];
                  err.statusCode = res.statusCode;
                  err.requestId = res.headers["x-amzn-requestid"];
                  err.message = op + " [" + res.statusCode + "]: " + (json.message || json["__type"]);
                  err.code = err.type.substring(err.type.lastIndexOf("#") + 1, err.type.length);
                  err.data = json;
                  return cb(err);
                } else {
                  return cb(null, json);
                }
              });
            });
            req.on("error", function(err) {
              cb(err);
              return cb = undefined;
            });
            req.write(rqBody);
            return req.end();
          };
          return (retry = function(c) {
            return executeRequest(function(err, json) {
              if (err != null) {
                if (err.statusCode === 500 || err.statusCode === 503) {
                  if (c <= my.retries) {
                    return setTimeout((function() {
                      return retry(c + 1);
                    }), Math.pow(4, c) * 100);
                  } else {
                    return cb(err);
                  }
                } else if (err.statusCode === 400 && err.code === "ProvisionedThroughputExceededException") {
                  if (c === 0) {
                    return retry(c + 1);
                  } else if (c <= my.retries && c <= 10) {
                    return setTimeout((function() {
                      return retry(c + 1);
                    }), Math.pow(2, c - 1) * (25 * (Math.random() + 1)));
                  } else {
                    return cb(err);
                  }
                } else {
                  return cb(err);
                }
              } else {
                return cb(null, json);
              }
            });
          })(0);
        }
      });
      return deferred.promise;
    };
    /*
    retrieves a temporary access key and secret from amazon STS
    @param cb callback(err) err specified in case of error
    */

    auth = function(cb) {
      var cqs, encoding, hmac, host, sts;
      if (my.access && my.access.expiration.getTime() < ((new Date).getTime() + 60000)) {
        delete my.access;
        my.inAuth = false;
      }
      if (my.access) {
        cb();
        return;
      }
      that.once("auth", cb);
      if (my.inAuth) {
        return;
      }
      my.inAuth = true;
      cqs = "AWSAccessKeyId" + "=" + encodeURIComponent(my.accessKeyId) + "&" + "Action" + "=" + "GetSessionToken" + "&" + "DurationSeconds" + "=" + "3600" + "&" + "SignatureMethod" + "=" + "HmacSHA256" + "&" + "SignatureVersion" + "=" + "2" + "&" + "Timestamp" + "=" + encodeURIComponent((new Date).toISOString().substr(0, 19) + "Z") + "&" + "Version" + "=" + "2011-06-15";
      host = "sts.amazonaws.com";
      sts = "GET" + "\n" + host + "\n" + "/" + "\n" + cqs;
      hmac = crypto.createHmac("sha256", my.secretAccessKey);
      hmac.update(sts);
      cqs += "&" + "Signature" + "=" + encodeURIComponent(hmac.digest(encoding = "base64"));
      return https.get({
        host: host,
        path: "/?" + cqs
      }, function(res) {
        var xml;
        xml = "";
        res.on("data", function(chunk) {
          return xml += chunk;
        });
        return res.on("end", function() {
          var aki_r, cd_r, e_r, err, msg_r, sak_r, st_r, tp_r;
          st_r = /\<SessionToken\>(.*)\<\/SessionToken\>/.exec(xml);
          sak_r = /\<SecretAccessKey\>(.*)\<\/SecretAccessKey\>/.exec(xml);
          aki_r = /\<AccessKeyId\>(.*)\<\/AccessKeyId\>/.exec(xml);
          e_r = /\<Expiration\>(.*)\<\/Expiration\>/.exec(xml);
          if (st_r && sak_r && aki_r && e_r) {
            my.access = {
              sessionToken: st_r[1],
              secretAccessKey: sak_r[1],
              accessKeyId: aki_r[1],
              expiration: new Date(e_r[1])
            };
            my.inAuth = false;
            return that.emit("auth");
          } else {
            tp_r = /\<Type\>(.*)\<\/Type\>/.exec(xml);
            cd_r = /\<Code\>(.*)\<\/Code\>/.exec(xml);
            msg_r = /\<Message\>(.*)\<\/Message\>/.exec(xml);
            if (tp_r && cd_r && msg_r) {
              err = new Error("AUTH [" + cd_r[1] + "]: " + msg_r[1]);
              err.type = tp_r[1];
              err.code = cd_r[1];
              my.inAuth = false;
              return that.emit("auth", err);
            } else {
              err = new Error("AUTH: Unknown Error");
              my.inAuth = false;
              return that.emit("auth", err);
            }
          }
        });
      }).on("error", function(err) {
        my.inAuth = false;
        return that.emit("auth", err);
      });
    };
    return execute;
  };

  module.exports = aws;

}).call(this);
